import jax
import jax.numpy as jnp
from jax import vmap, random, jit, lax
from jax.flatten_util import ravel_pytree
from functools import partial
    
# can comment the partial while trying to write the code
@partial(jit, static_argnums=(5, 6, 7))
def hsic(
    X,
    Y,
    key,
    alpha=0.05,
    bandwidth=1,
    kernel="gaussian",
    B=2000, 
    return_dictionary=False,
):
    """
    Independence HSIC test.
     
    Given data from one distribution and data from another distribution,
    return 0 if the test fails to reject the null 
    (i.e. paired data is independent), 
    or return 1 if the test rejects the null 
    (i.e. paired data is dependent).
    
    Fixing the sample size and the dimension, the first time the function is
    run it is getting compiled. After that, the function can fastly be evaluated on 
    any data with the same sample size and dimension.
    
    Parameters
    ----------
    key:
        Jax random key (can be generated by jax.random.PRNGKey(seed) for an integer seed).
    X : array_like
        The shape of X must be of the form (m, d) where m is the number
        of samples and d is the dimension.
    Y: array_like
        The shape of X must be of the form (m, d) where m is the number
        of samples and d is the dimension.
    alpha: scalar
        The value of alpha must be between 0 and 1.
    kernel: str
        The value of kernel must be "gaussian", "laplace", "imq"
    bandwidth: scalar
        The value of the bandwidth must be positive.
    B: int
        Number of permutations to approximate the quantiles.
    return_dictionary: bool
        If true, a dictionary is returned containing for each single test: 
        the test output, the kernel, the bandwidth, the HSIC value, the HSIC quantile value, 
        the p-value and the p-value threshold value.      
        
    Returns
    -------
    output: int
        0 if the HSIC test fails to reject the null 
            (i.e. data comes from the same distribution)
        1 if the HSIC test rejects the null 
            (i.e. data comes from different distributions)
    dictionary: dict
        Returned only if return_dictionary is True.
        Dictionary containing the test output, the kernel, the bandwidth, 
        the HSIC value, the HSIC quantile value, 
        the p-value and the p-value threshold value.
    """    
    # Assertions
    m = X.shape[0]
    n = Y.shape[0]
    mn = m + n
    assert n >= 2 and m >= 2
    assert X.shape == Y.shape
    # assert epsilon != 0
    # assert 0 < alpha  and alpha < 1
    assert kernel in ("gaussian", "laplace", "imq")
    # assert bandwidth > 0
    assert B > 0 and type(B) == int
    # assert 0 <= delta and delta <= 1
    # assert seed > 0 and type(seed) == int
    l = "l2" if kernel in ("gaussian", "imq") else "l1"

    # Setup for permutations
    key, subkey = random.split(key)
    # (B+1, m): rows of permuted indices
    idx = random.permutation(subkey, jnp.array([[i for i in range(m)]] * (B + 1)), axis=1, independent=True)  
    idx = idx.at[B].set(jnp.array([i for i in range(m)]))
    
    # compute both kernel matrices
    pairwise_matrix_X = distances(X, X, l, matrix=True)
    K = kernel_matrix(pairwise_matrix_X, l, kernel, bandwidth)
    pairwise_matrix_Y = distances(Y, Y, l, matrix=True)
    L = kernel_matrix(pairwise_matrix_Y, l, kernel, bandwidth)

    # compute HSIC permuted values (B + 1, )
    # check the scaling 
    compute_hsic = lambda index : jnp.sum(K[index][:, index] * L) / (n - 1) ** 2
    # lax.map gives [compute_hsic(i) for i in idx]
    hsic_values = lax.map(compute_hsic, idx)  # (B + 1, )
    hsic_original = hsic_values[B]

    # test output test (p-value)
    p_val = jnp.mean((hsic_values - hsic_original >= 0))
    threshold = alpha
    # reject if p_val <= threshold
    reject_p_val = p_val <= threshold

    # Comment: doing this is equivalent (understand why)
    # test output test (quantile)
    hsic_values_sorted = jnp.sort(hsic_values) # (B + 1, )
    quantile = hsic_values_sorted[(jnp.ceil((B + 1) * (1 - alpha))).astype(int) - 1]
    # reject if hsic_original > quantile
    reject_hsic_val = hsic_original > quantile
   
    #assert reject_p_val == reject_mmd_val
    output = reject_p_val

    # create rejection dictionary 
    reject_dictionary = {}
    reject_dictionary["HSIC test reject"] = reject_p_val
    reject_dictionary["Kernel " + kernel] = True
    reject_dictionary["Bandwidth"] = bandwidth
    reject_dictionary["HSIC"] = hsic_original
    reject_dictionary["HSIC quantile"] = quantile
    reject_dictionary["p-value"] = p_val
    reject_dictionary["p-value threshold"] = threshold

    if return_dictionary:
        return reject_p_val.astype(int), reject_dictionary
    else:
        return reject_p_val.astype(int)

    
def kernel_matrix(pairwise_matrix, l, kernel, bandwidth):
    """
    Compute kernel matrix for a given kernel and bandwidth. 

    inputs: pairwise_matrix: (2m,2m) matrix of pairwise distances
            l: "l1" or "l2" or "l2sq"
            kernel: string from ("gaussian", "laplace", "imq", "matern_0.5_l1", "matern_1.5_l1", "matern_2.5_l1", "matern_3.5_l1", "matern_4.5_l1", "matern_0.5_l2", "matern_1.5_l2", "matern_2.5_l2", "matern_3.5_l2", "matern_4.5_l2")
    output: (2m,2m) pairwise distance matrix

    Warning: The pair of variables l and kernel must be valid.
    """
    d = pairwise_matrix / bandwidth
    if kernel == "gaussian" and l == "l2":
        return  jnp.exp(-d ** 2)
    elif kernel == "imq" and l == "l2":
        return (1 + d ** 2) ** (-0.5)
    elif (kernel == "matern_0.5_l1" and l == "l1") or (kernel == "matern_0.5_l2" and l == "l2") or (kernel == "laplace" and l == "l1"):
        return  jnp.exp(-d)
    elif (kernel == "matern_1.5_l1" and l == "l1") or (kernel == "matern_1.5_l2" and l == "l2"):
        return (1 + jnp.sqrt(3) * d) * jnp.exp(- jnp.sqrt(3) * d)
    elif (kernel == "matern_2.5_l1" and l == "l1") or (kernel == "matern_2.5_l2" and l == "l2"):
        return (1 + jnp.sqrt(5) * d + 5 / 3 * d ** 2) * jnp.exp(- jnp.sqrt(5) * d)
    elif (kernel == "matern_3.5_l1" and l == "l1") or (kernel == "matern_3.5_l2" and l == "l2"):
        return (1 + jnp.sqrt(7) * d + 2 * 7 / 5 * d ** 2 + 7 * jnp.sqrt(7) / 3 / 5 * d ** 3) * jnp.exp(- jnp.sqrt(7) * d)
    elif (kernel == "matern_4.5_l1" and l == "l1") or (kernel == "matern_4.5_l2" and l == "l2"):
        return (1 + 3 * d + 3 * (6 ** 2) / 28 * d ** 2 + (6 ** 3) / 84 * d ** 3 + (6 ** 4) / 1680 * d ** 4) * jnp.exp(- 3 * d)
    else:
        raise ValueError(
            'The values of "l" and "kernel" are not valid.'
        )


def distances(X, Y, l, max_samples=None, matrix=False):
    if l == "l1":
        def dist(x, y):
            z = x - y
            return jnp.sum(jnp.abs(z))
    elif l == "l2":
        def dist(x, y):
            z = x - y
            return jnp.sqrt(jnp.sum(jnp.square(z)))
    else:
        raise ValueError("Value of 'l' must be either 'l1' or 'l2'.")
    vmapped_dist = vmap(dist, in_axes=(0, None))
    pairwise_dist = vmap(vmapped_dist, in_axes=(None, 0))
    output = pairwise_dist(X[:max_samples], Y[:max_samples])
    if matrix:
        return output
    else:
        return output[jnp.triu_indices(output.shape[0])]


def human_readable_dict(dictionary):
    """
    Transform all jax arrays of one element into scalars.
    """
    meta_keys = dictionary.keys()
    for meta_key in meta_keys:
        if isinstance(dictionary[meta_key], jnp.ndarray):
            dictionary[meta_key] = dictionary[meta_key].item()
        elif isinstance(dictionary[meta_key], dict):
            for key in dictionary[meta_key].keys():
                if isinstance(dictionary[meta_key][key], jnp.ndarray):
                    dictionary[meta_key][key] = dictionary[meta_key][key].item()
