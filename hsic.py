import jax
import jax.numpy as jnp
from jax import vmap, random, jit, lax
from jax.flatten_util import ravel_pytree
from functools import partial
from kernel import kernel_matrix, distances
    
# careful epsilon = 0 will give 1 / 0 = inf
@partial(jit, static_argnums=(7, 8, 9))
def dpmmd(
    key,
    X,
    Y,
    epsilon, # epsilon = jnp.inf no privacy
    delta=0, # delta = 1 no privacy
    alpha=0.05,
    bandwidth=1,
    kernel="gaussian",
    B=2000, 
    return_dictionary=False,
):
    """
    Differential Privacy Two-Sample dpMMD test.
     
    Given data from one distribution and data from another distribution,
    return 0 if the test fails to reject the null 
    (i.e. data comes from the same distribution), 
    or return 1 if the test rejects the null 
    (i.e. data comes from different distributions).
    
    Fixing the two sample sizes and the dimension, the first time the function is
    run it is getting compiled. After that, the function can fastly be evaluated on 
    any data with the same sample sizes and dimension.
    
    Parameters
    ----------
    key:
        Jax random key (can be generated by jax.random.PRNGKey(seed) for an integer seed).
    X : array_like
        The shape of X must be of the form (m, d) where m is the number
        of samples and d is the dimension.
    Y: array_like
        The shape of X must be of the form (n, d) where n is the number
        of samples and d is the dimension.
    epsilon: scalar
        Differential privacy level (positive scalar).
        If epsilon = jnp.inf, non-DP MMD test is being run.
    delta: scalar
        Approximate differential privacy level (0 <= delta <= 1).
    alpha: scalar
        The value of alpha must be between 0 and 1.
    kernel: str
        The value of kernel must be "gaussian", "laplace", "imq"
    bandwidth: scalar
        The value of the bandwidth must be positive.
    B: int
        Number of permutations to approximate the quantiles.
    return_dictionary: bool
        If true, a dictionary is returned containing for each single test: 
        the test output, the kernel, the bandwidth, the MMD value, the MMD quantile value, 
        the p-value and the p-value threshold value.      
        
    Returns
    -------
    output: int
        0 if the dpMMD test fails to reject the null 
            (i.e. data comes from the same distribution)
        1 if the dpMMD test rejects the null 
            (i.e. data comes from different distributions)
    dictionary: dict
        Returned only if return_dictionary is True.
        Dictionary containing the test output, the kernel, the bandwidth, 
        the MMD value, the MMD quantile value, 
        the p-value and the p-value threshold value.
    """    
    # Assertions
    m = X.shape[0]
    n = Y.shape[0]
    mn = m + n
    assert n >= 2 and m >= 2
    assert X.shape[1] == Y.shape[1]
    # assert epsilon != 0
    # assert 0 < alpha  and alpha < 1
    assert kernel in ("gaussian", "laplace", "imq")
    #assert bandwidth > 0
    assert B > 0 and type(B) == int
    # assert seed > 0 and type(seed) == int
    l = "l2" if kernel in ("gaussian", "imq") else "l1"

    # DP level
    # threshold delta between zero and one
    delta = jnp.minimum(delta, 1)
    delta = jnp.maximum(delta, 0)
    # epsilon cannot be negative (careful epsilon = 0)
    epsilon = jnp.abs(epsilon)
    privacy_level = epsilon + jnp.log(1 / (1 - delta))
    
    # DP noise
    key, subkey = random.split(key)
    sensitivity = jnp.sqrt(2) / jnp.minimum(n, m)
    laplace_noise = random.laplace(subkey, shape=(B + 1,))
    dp_noise = laplace_noise * 2 * sensitivity / privacy_level

    # Setup for permutations
    key, subkey = random.split(key)
    # (B+1, m+n): rows of permuted indices
    idx = random.permutation(subkey, jnp.array([[i for i in range(m + n)]] * (B + 1)), axis=1, independent=True)   
    v = jnp.concatenate((jnp.ones(m) / m, - jnp.ones(n) / n))  # (m+n, )
    V_stack = jnp.tile(v, (B + 1, 1))  # (B+1, m+n)
    V = jnp.take_along_axis(V_stack, idx, axis=1)  # (B+1, m+n): permute the entries of the rows
    V = V.at[B].set(v) # (B+1)th entry is the original MMD (no permutation)
    V = V.transpose()  # (m+n, B+1)
        
    # Compute all simulated MMD estimates and quantile
    Z = jnp.concatenate((X, Y))
    pairwise_matrix = distances(Z, Z, l, matrix=True)
    K = kernel_matrix(pairwise_matrix, l, kernel, bandwidth)
    # compute MMD permuted values (B + 1, )
    mmd_values = jnp.sum(V * (K @ V), 0)
    mmd_values = mmd_values + dp_noise # differential privacy
    mmd_original = mmd_values[B]
    mmd_values_sorted = jnp.sort(mmd_values) # (B + 1, )

    # test output test (p-value)
    p_val = jnp.mean((mmd_values_sorted - mmd_original >= 0))
    threshold = alpha
    # reject if p_val <= threshold
    reject_p_val = p_val <= threshold

    # test output test (quantile)
    quantile = mmd_values_sorted[(jnp.ceil((B + 1) * (1 - alpha))).astype(int) - 1]
    # reject if mmd_original > quantile
    reject_mmd_val = mmd_original > quantile
   
    #assert reject_p_val == reject_mmd_val
    output = reject_p_val

    # create rejection dictionary 
    reject_dictionary = {}
    reject_dictionary["dpMMD test reject"] = reject_p_val
    reject_dictionary["Kernel " + kernel] = True
    reject_dictionary["Bandwidth"] = bandwidth
    reject_dictionary["MMD"] = mmd_original
    reject_dictionary["MMD quantile"] = quantile
    reject_dictionary["p-value"] = p_val
    reject_dictionary["p-value threshold"] = threshold

    if return_dictionary:
        return reject_p_val.astype(int), reject_dictionary
    else:
        return reject_p_val.astype(int)
    
# careful epsilon = 0 will give 1 / 0 = inf
@partial(jit, static_argnums=(7, 8, 9))
def dphsic(
    key,
    X,
    Y,
    epsilon, # epsilon = jnp.inf no privacy
    delta=0, # delta = 1 no privacy
    alpha=0.05,
    bandwidth=1,
    kernel="gaussian",
    B=2000, 
    return_dictionary=False,
):
    """
    Differential Privacy Independence dpHSIC test.
     
    Given data from one distribution and data from another distribution,
    return 0 if the test fails to reject the null 
    (i.e. paired data is independent), 
    or return 1 if the test rejects the null 
    (i.e. paired data is dependent).
    
    Fixing the sample size and the dimension, the first time the function is
    run it is getting compiled. After that, the function can fastly be evaluated on 
    any data with the same sample size and dimension.
    
    Parameters
    ----------
    key:
        Jax random key (can be generated by jax.random.PRNGKey(seed) for an integer seed).
    X : array_like
        The shape of X must be of the form (m, d) where m is the number
        of samples and d is the dimension.
    Y: array_like
        The shape of X must be of the form (m, d) where m is the number
        of samples and d is the dimension.
    epsilon: scalar
        Differential privacy level (positive scalar).
        If epsilon = jnp.inf, non-DP HSIC test is being run.
    delta: scalar
        Approximate differential privacy level (0 <= delta <= 1).
    alpha: scalar
        The value of alpha must be between 0 and 1.
    kernel: str
        The value of kernel must be "gaussian", "laplace", "imq"
    bandwidth: scalar
        The value of the bandwidth must be positive.
    B: int
        Number of permutations to approximate the quantiles.
    return_dictionary: bool
        If true, a dictionary is returned containing for each single test: 
        the test output, the kernel, the bandwidth, the HSIC value, the HSIC quantile value, 
        the p-value and the p-value threshold value.      
        
    Returns
    -------
    output: int
        0 if the dpHSIC test fails to reject the null 
            (i.e. data comes from the same distribution)
        1 if the dpHSIC test rejects the null 
            (i.e. data comes from different distributions)
    dictionary: dict
        Returned only if return_dictionary is True.
        Dictionary containing the test output, the kernel, the bandwidth, 
        the HSIC value, the HSIC quantile value, 
        the p-value and the p-value threshold value.
    """    
    # Assertions
    m = X.shape[0]
    n = Y.shape[0]
    mn = m + n
    assert n >= 2 and m >= 2
    assert X.shape[1] == Y.shape[1]
    # assert epsilon != 0
    # assert 0 < alpha  and alpha < 1
    assert kernel in ("gaussian", "laplace", "imq")
    # assert bandwidth > 0
    assert B > 0 and type(B) == int
    # assert 0 <= delta and delta <= 1
    # assert seed > 0 and type(seed) == int
    l = "l2" if kernel in ("gaussian", "imq") else "l1"
    
    # DP level
    # threshold delta between zero and one
    delta = jnp.minimum(delta, 1)
    delta = jnp.maximum(delta, 0)
    # epsilon cannot be negative (careful epsilon = 0)
    epsilon = jnp.abs(epsilon)
    privacy_level = epsilon + jnp.log(1 / (1 - delta))

    # DP noise
    key, subkey = random.split(key)
    sensitivity = 4 * (n - 1) / n ** 2
    laplace_noise = random.laplace(subkey, shape=(B + 1,))
    dp_noise = laplace_noise * 2 * sensitivity / privacy_level

    # Setup for permutations
    key, subkey = random.split(key)
    # (B+1, m): rows of permuted indices
    idx = random.permutation(subkey, jnp.array([[i for i in range(m)]] * (B + 1)), axis=1, independent=True)  
    idx = idx.at[B].set(jnp.array([i for i in range(m)]))
    
    # compute both kernel matrices
    pairwise_matrix_X = distances(X, X, l, matrix=True)
    K = kernel_matrix(pairwise_matrix_X, l, kernel, bandwidth)
    pairwise_matrix_Y = distances(Y, Y, l, matrix=True)
    L = kernel_matrix(pairwise_matrix_Y, l, kernel, bandwidth)

    # compute HSIC permuted values (B + 1, )
    compute_hsic = lambda index : jnp.sum(K[index][:, index] * L)
    hsic_values = lax.map(compute_hsic, idx)  # (B + 1, )
    hsic_values = hsic_values + dp_noise # differential privacy
    hsic_original = hsic_values[B]
    hsic_values_sorted = jnp.sort(hsic_values) # (B + 1, )

    # test output test (p-value)
    p_val = jnp.mean((hsic_values_sorted - hsic_original >= 0))
    threshold = alpha
    # reject if p_val <= threshold
    reject_p_val = p_val <= threshold

    # test output test (quantile)
    quantile = hsic_values_sorted[(jnp.ceil((B + 1) * (1 - alpha))).astype(int) - 1]
    # reject if hsic_original > quantile
    reject_hsic_val = hsic_original > quantile
   
    #assert reject_p_val == reject_mmd_val
    output = reject_p_val

    # create rejection dictionary 
    reject_dictionary = {}
    reject_dictionary["dpHSIC test reject"] = reject_p_val
    reject_dictionary["Kernel " + kernel] = True
    reject_dictionary["Bandwidth"] = bandwidth
    reject_dictionary["HSIC"] = hsic_original
    reject_dictionary["HSIC quantile"] = quantile
    reject_dictionary["p-value"] = p_val
    reject_dictionary["p-value threshold"] = threshold

    if return_dictionary:
        return reject_p_val.astype(int), reject_dictionary
    else:
        return reject_p_val.astype(int)


def human_readable_dict(dictionary):
    """
    Transform all jax arrays of one element into scalars.
    """
    meta_keys = dictionary.keys()
    for meta_key in meta_keys:
        if isinstance(dictionary[meta_key], jnp.ndarray):
            dictionary[meta_key] = dictionary[meta_key].item()
        elif isinstance(dictionary[meta_key], dict):
            for key in dictionary[meta_key].keys():
                if isinstance(dictionary[meta_key][key], jnp.ndarray):
                    dictionary[meta_key][key] = dictionary[meta_key][key].item()
